\documentclass[a4paper,11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\usepackage{hyperref}
\usepackage{amsmath}

% Code highligting
% \usepackage{minted}
\usepackage[outputdir=output/tex]{minted} % iom min makefile

\newenvironment{longlisting}{\captionsetup{type=listing}}{}
% \renewcommand\listoflistingscaption{Källkod....}
\renewcommand\listoflistingscaption{List of source codes}
%\setmintedinline[sql]{breaklines=true,breakanywhere=true} % necessary for breakanywhere to work later on.

\usepackage{graphicx}
\usepackage{pgf}
\usepackage{wrapfig}
\usepackage[font=footnotesize,labelfont=bf,skip=2pt]{caption}
\usepackage{subcaption}

\usepackage{pgfplots}
\pgfplotsset{compat=1.18}

\usepackage{pgfplotstable}
\usepackage{booktabs}


% Spacing
\usepackage{titlesec}
\titlespacing*{\section}{0pt}{2ex plus 1ex minus .2ex}{1ex plus .2ex}


\begin{document}

\title{
    An environment
\\\small{Programmering II, ID1019, VT24 P1}
}
\author{Vincent Ferrigan \href{mailto:ferrigan@kth.se}{ferrigan@kth.se}}

% \date{\today}
\date{Spring Term 2023}

\maketitle

\section*{Introduction}
\label{sec:introduction}
%\TODO lägg till en kort beskrivning om uppgiften och dess tre delar
%The assignment involves implementing a key-value database,
%also referred to as a "map".
%different data structure implementations
%
%
The assignment involves exploring and analyzing the efficiency of
different data structure implementations for storing
and retrieving key-value pairs.
(This key-value database is also referred to as ''map'').
The task involves developing two distinct implementations:
one based on a simple list structure and
another on a tree structure.
The latter will be implemented as a \emph{Binary Search Tree} (BST).
%A BST is a node-based binary tree data structure where each node has a key and value, and satisfies the BST property: the key in each node must be greater than all keys in the left subtree and less than those in the right subtree.

These two ''custom implementations'' were later compared with
Elixir's built-in Map module in terms of performance.

This assigment is based on the instruction
\href{https://people.kth.se/~johanmon/courses/id1019/seminars/environment/environment.pdf}{An environment}
by course examiner Johan Montelius.
The Mix-project for this assignment, including all relative functions and Unit-test can be found on GitHub:
\href{https://github.com/VincentFerrigan/kth-id1019-programming-ii/tree/main/tasks/2/mymaps}{GitHub-Repo}% TODO FUNKAR DEN? ÄNDRA NAMN

\section*{Methods}
\label{sec:methods}

\subsection*{Literature Study}
\label{subsec:methods}
The pre-recorded lectures on
\href{https://canvas.kth.se/courses/44911/assignments/syllabus}{Lists, Recursion and Trees},
given by the course examiner, were reviewed.
Elixir-syntax and similar topics was acquired
from both the
\href{https://elixir-lang.org/docs.html}{Elixir official documentation}
and the free Elixir Tutorial
\href{https://elixirschool.com/en}{Elixir School
website}.
The project group also relied on textbooks found on
\href{https://learning.oreilly.com}{O'Reilly Media},
especially Brute Tate's
\href{https://learning.oreilly.com/library/view/programmer-passport-elixir/9781680509649/}{Programmer Passport: Elixir}.

\subsubsection*{Tools and packages}
\label{subsec:tools}
All code was written in \emph{IntelliJ IDEA}.
Quick-fixes and editing was, however, done in \emph{Vim}. 
\emph{GIT} and \emph{GitHub} was used for version control.
Tests were performed with Elixir's built-in test framework \emph{ExUnit.}
For the visualization of benchmarking results, \emph{GNUPlot} was used.
This report was also written in plain text mode -- \LaTeX.

\subsubsection*{The overall Work-flow} % \todo BYT NAMN?
\label{subsec:workflow}
%/TODO Är det här jag har med kod?? Eller kör jag det i resultat delen? Annars kanske det enbart räcker med att skriva varje steg för steg.
The development was an iterative approach with ''trail and errors''.
The author practiced
\href{https://www.elixirwiki.com/wiki/Test-Driven_Development_in_Elixir}{Test Driven Development}
(TDD).
The basic steps follows the \emph{Red-Green-Refactor cycle}; writing failing tests (Red), make them pass (Green),
and finally refactor the code.

In addition to the list- and tree-based data structure implementations of map,
a wrapper module (\mintinline{elixir}{MapWrapper}) was developed to provide a
consistent interface for Elixir’s built-in Map,
aligning its
\mintinline{elixir}{put/3},
\mintinline{elixir}{get/2}, and
\mintinline{elixir}{delete/2} functions with the
\mintinline{elixir}{add/3},
\mintinline{elixir}{lookup/2}, and
\mintinline{elixir}{remove/2} functions used in the custom implementations.

\begin{minted}[fontsize=\small]{elixir}
defmodule MapWrapper do
    def new(), do: %{}
    def add(map, key, value), do: Map.put(map, key, value)
    def lookup(map, key), do: Map.get(map, key)
    def remove(map, key), do: Map.delete(map, key)
end
%\end{minted}


\section*{Result}
\label{sec:result}
%\TODO: Här inkluderar du alla benchmarks

% ...

\begin{table}[h]
    \centering
    \pgfplotstabletypeset[
    col sep=space, % or col sep=tab, depending on your .dat file
    columns/Size/.style={column name=Size (n)},
    columns/Add/.style={column name=Add Time (us)},
    columns/Lookup/.style={column name=Lookup Time (\mu s)},
    columns/Remove/.style={column name=Remove Time (us)},
    ]{../data/list.dat}
    \caption{Performance Metrics for the Implementation}
    \label{tab:performance_metrics}
\end{table}

\begin{table}[h]
    \centering
    \pgfplotstabletypeset[
        col sep=space, % or col sep=tab, depending on your .dat file
        header=true,    % to use the first line of .dat file as header
        every head row/.style={before row=\hline,after row=\hline},
        every last row/.style={after row=\hline},
    ]{../data/list.dat}
    \caption{Performance Metrics for the Implementation}
    \label{tab:performance_metrics22}
\end{table}

\begin{table}[htbp]
    \centering
    \pgfplotstabletypeset[
        col sep=space, % adjust this based on your .dat file format
        every head row/.style={before row=\toprule, after row=\midrule},
        every last row/.style={after row=\bottomrule},
        columns/Size/.style={column name=Size (n)},
        columns/List/.style={column name=List (\mu s)},
        columns/Tree/.style={column name=Tree (\mu s)},
        columns/Map/.style={column name=Map (\mu s)},
        columns/List:Tree/.style={column name=$\frac{List}{Tree}$},
        columns/List:Map/.style={column name=$\frac{List}{Map}$},
        columns/Tree:Map/.style={column name=$\frac{Tree}{Map}$},
    ]{../data/combined_add_ratios.dat}
    \caption{Comparative Performance Metrics and Ratios for the Add operation}
    \label{tab:performance_metrics_and_ratios_add}
\end{table}

%\begin{table}[htbp]
%    \centering
%    \pgfplotstabletypeset[
%        col sep=space, % Columns are separated by space
%        header=has colnames, % The first line contains the column names
%        string type,
%        every head row/.style={before row=\toprule, after row=\midrule},
%        every last row/.style={after row=\bottomrule},
%        display columns/0/.style={column name=Size},
%        display columns/1/.style={column name=List Add},
%        display columns/2/.style={column name=Tree Add},
%        display columns/3/.style={column name=Map Add},
%        display columns/4/.style={column name=Tree/List Ratio},
%        display columns/5/.style={column name=List/Map Ratio},
%        display columns/6/.style={column name=Tree/Map Ratio},
%    ]{path/to/combined_add_ratios.dat}
%    \caption{Comparative Performance Metrics and Ratios}
%    \label{tab:performance_metrics_and_ratios}
%\end{table}
%
%
%\begin{table}[htbp]
%    \centering
%    \pgfplotstabletypeset[
%        col sep=space, % adjust this based on your .dat file format
%        string type,
%        every head row/.style={before row=\toprule, after row=\midrule},
%        every last row/.style={after row=\bottomrule},
%        columns/Size/.style={column name=Size},
%        columns/List Add/.style={column name=List Lookup},
%        columns/Tree Add/.style={column name=Tree Lookup},
%        columns/Map Add/.style={column name=Map Lookup},
%        columns/Tree/List Ratio/.style={column name=Tree/List Ratio},
%        columns/List/Map Ratio/.style={column name=List/Map Ratio},
%        columns/Tree/Map Ratio/.style={column name=Tree/Map Ratio},
%    ]{../data/combined_lookup_ratios.dat}
%    \caption{Comparative Performance Metrics and Ratios for the Lookup operation}
%    \label{tab:performance_metrics_and_ratios_lookup}
%\end{table}



%The head function
%\mintinline{elixir}{Derivative.run/3}
%calculates and prints the derivative of a given mathematical expression,
%along with its simplified form and calculated value at a specific point (see example
%below).
%\begin{minted}[fontsize=\small]{elixir}
%iex(1)> f = {:add, {:num, 7}, {:pow, {:var, :x}, {:num, 2}}}
%{:add, {:num, 7}, {:pow, {:var, :x}, {:num, 2}}}
%iex(2)> Derivative.run(f, :x, 3)
%The steps taken to find the derivative of function 7 + (x)^2,
%at given value of x = 3.
%
%Derivative: 0 + (1 * (2 * (x)^1))
%Simplified: 2x
%Calculated: 6
%:ok
%\end{minted}
%This function, found in listing
%~\ref{listing:run()},
%takes a mathematical expression represented in a structured format
%(as AST defined by the \mintinline{elixir}{expr()} type),
%a variable as an \mintinline{elixir}{atom()}, and a numeric value.
%It computes the derivative of the expression with respect to the given variable, simplifies this derivative,
%calculates its value at the specified number, and then simplifies this calculated value.
%The original derivative, its simplified form, and the final simplified calculated value are printed to the console.
%\begin{longlisting}
%    \inputminted[
%        label=Derivative.run/3,
%%        linenos=true,
%        firstline=67,
%        lastline=79,
%        xleftmargin=-5mm,  % Adjust this value as needed
%%        frame=single,
%        fontsize=\small,
%    ]{elixir}{../lib/derivative.ex}
%    \caption{
%        Function for calculating the derivative of a given function at given value of variable.
%    }
%    \label{listing:run()}
%\end{longlisting}
%The derivative, its simplified form, and the calculation result are printed to the console
%(a.k.a. \emph{pretty printing}).
%On successful execution the function returns an
%\mintinline{elixir}{:ok}.
%%The function takes the following parameters and returns an \mintinline{elixir}{:ok} on successful execution:
%%% /todo Should it raise an exection? Nice to have
%%\begin{description}\small
%%    \item[\mintinline{elixir}{ast}:] The mathematical expression to be differentiated (type \mintinline{elixir}{expr()}).
%%    \item[\mintinline{elixir}{variable}:] The variable (as an \mintinline{elixir}{atom()}) with respect to which the derivative is to be taken.
%%    \item[\mintinline{elixir}{value}:] The numeric value at which the derivative is to be evaluated.
%%\end{description}
%In the report, all auxiliary functions will be briefly explained.
%\subsubsection*{DSL}
%The assignment also includes metaprogramming.
%i.e. \mintinline{elixir}{@type} definitions creating a small \emph{Domain Specific Language} DSL.
%A DSL is a specialized mini-language created to express ideas, configurations, or instructions in a specific domain
%more efficiently and clearly.
%In this case, the domain is mathematical expressions,
%and our AST structure is tailored to express these expressions in a specific, structured way.
%%\begin{minted}[fontsize=\small]{elixir}
%%@type literal() :: {:num, number()} | {:var, atom()}
%%
%%@type expr() ::
%%  {:add, expr(), expr()}    # Addition of two expressions.
%%| {:mul, expr(), expr()}    # Multiplication of two expressions.
%%| {:pow, expr(), literal()} # An expression raised to a literal power.
%%| {:ln, expr()}             # Natural logarithm of an expression.
%%....
%%| literal()
%%\end{minted}
%%
%\subsubsection*{Finding Derivatives}
%In Elixir it is possible to have several definitions of the same function and arity.
%This technique is called function-overloading where and in this case.
%In order to choose which function to call,
%Elixir pattern matches the parameters.
%(The order of matching is top-down as in regular pattern matching.)
%All function, included the derivative function,
%\mintinline{bash}{finding_derivative/2} are overloaded.
%The author will only mention a few.
%
%The derivative function follows the \emph{quotient rule} i.e.
%%\usepackage{amsmath}
%let \( f(x) = \frac{g(x)}{h(x)} \) where \( g \) and \( h \) are differentiable functions.
%The derivative of \( f \) is derived as follows:
%    \begin{align*}
%        f'(x) &= \left( \frac{g(x)}{h(x)} \right)'
%        &= \frac{g'(x)h(x) - g(x)h'(x)}{[h(x)]^2}
%    \end{align*}
%Which translates to the following:
%\begin{minted}[fontsize=\small]{elixir}
%# Quotient rule
%def find_derivative({:div, e1, e2}, v) do
%  {:div,
%    {:add,
%      {:mul, find_derivative(e1, v), e2},
%      {:mul, {:num, -1}, {:mul, e1, find_derivative(e2, v)}}},
%    {:pow, e2, {:num, 2}}}
%  end
%
%\end{minted}
%Naturally, simplifying these expressions are required.
%For example, using the following rule of exponents:
%\textbf{Zero Exponent Rule:} \( a^0 = 1 \), for \( a \neq 0 \) and
%\textbf{Power of a Product Rule:} \( (ab)^n = a^n b^n \).
%\begin{minted}[fontsize=\small]{elixir}
%@spec simplify(expr()) :: expr()
%def simplify({:pow, e1, e2}), do: simplify_pow(simplify(e1), e2)
%def simplify_pow(_, {:num, 0}), do: {:num, 1}
%def simplify_pow(e, {:num, 1}), do: e
%def simplify_pow({:pow, e, {:num, n1}}, {:num, n2}) do
%  simplify({:pow, e, {:num, n1 * n2}})
%end
%# etc...
%\end{minted}
%\subsubsection*{Calculating}
%Calculate the value of a derived expression is straight forward.
%The \mintinline{elixir}{calculate/3} function ''calculates'' by mapping
%the variables with given value.
%\begin{minted}[fontsize=\small]{elixir}
%@spec calculate(expr(), atom(), number()) :: expr()
%def calculate({:num, n}, _, _), do: {:num, n}
%def calculate({:var, v}, v, n), do: {:num, n}
%def calculate({:var, v}, _, _), do: {:num, v}
%def calculate({:sin, e}, v, n), do: {:sin, calculate(e, v, n)}
%#...etc
%\end{minted}
%Please note that the result must be further simplified, as performed in the head function
%\mintinline{elixir}{Derivative.run/3} in
%~\ref{listing:run()},
%
%\subsubsection*{Pretty printing}
%For a more ''human readable'' output, the author applied pretty-printing functions
%on the AST. For example:
%\begin{minted}[fontsize=\small]{elixir}
%@spec pretty_print(expr()) :: string()
%def pretty_print({:num, n}), do: "#{n}"
%def pretty_print({:var, v}), do: "#{v}"
%def pretty_print({:mul, {:num, n}, {:var, v}}), do: "#{n}#{v}"
%def pretty_print({:mul, {:var, v}, {:num, n}}), do: "#{n}#{v}"
%def pretty_print({:add, e1, e2}), do: "#{pretty_print(e1)} + #{pretty_print(e2)}"
%def pretty_print({:div, e1, e2}), do: "(#{pretty_print(e1)}/#{pretty_print(e2)})"
%# etc...
%\end{minted}

\section*{Discussion}
\label{sec:discussion}
    % TODO Svara på alla frågor i pdf:en och gör en analys på benchen.
%Developing the simplification process was quite tricky.
%The program does not simplify all algebraic expressions all the way.
%One issue was applying the quotient rule for exponents.
%\begin{minted}[fontsize=\small]{elixir}
%iex(3)> g
%{:div, {:num, 1}, {:mul, {:num, 2}, {:var, :x}}}
%iex(4)> Derivative.run(g, :x, 3)
%The steps taken to find the derivative of function (1/2x),
%at given value of x = 3.
%Derivative: ((0 * 2x) + -((1 * (2 * 1) + 0x))/(2x)^2)
%Simplified: (-2/(2x)^2)
%Calculated: (-2/36.0)
%:ok
%\end{minted}

\end{document}

% \begin{longlisting}
%   \inputminted[
%       label=Q1-Function,
%       linenos=true,
%       bgcolor=lightgray,
%       firstline=28,
%       lastline=45,
% %        frame=single,
%       fontsize=\footnotesize,
%   ]{sql}{../../src/db/analytics/analytics.sql}
%   \caption{
%     Function for filtering and ordering output-table from view on given year.
%     }
%   \label{listing:q1_func}
% \end{longlisting}

% \begin{minted}{elixir}
%   def append([], b) do b end
%   def append([h|t], b) do
%     [h | append(t, b)]
%   end  
% \end{minted}

% If you want to include a program statement in running text you can do this
% using for example teletype-text: {\tt append([1,2,3],[4,5])}.
% using for example mintinline: \mintinline{elixir}{append([1,2,3],[3])}

% \begin{table}[h]
% \begin{center}
% \begin{tabular}{l|c|c}
% \textbf{prgm} & \textbf{run time} & \textbf{ratio}\\
% \hline
%   dummy      &  115 &     1.0\\
%   union      &  535 &     4.6\\
%   tailr      &  420 &     3.6\\
% \end{tabular}
% \caption{Union and friends, list of 50000 elements, run time in micro seconds}
% \label{tab:table1}
% \end{center}
% \end{table}


% \section*{Graphs}

% Once you start to generate graphs make sure that they are readable and
% have sensible information on the axes.

% There are many ways to generate graphs but you want to use a way that
% minimize manual work. My tool over the years has been {\em Gnuplot}
% and if you do not have a favorite tool you could give it a try. The
% Gnuplot program is a stand alone program that will generate a
% graph that you then can include in you report.

% If you work with Gnuplot you should write the commands needed to
% generate a diagram in a small script. Take a look in the file {\tt
%   fib.p} and you will see how the diagram in Fig.\ref{fig:images} was
% created from the data given in {\tt fib.dat} (the {\tt .png} file was
% generated from {\tt fib.pdf} using the Linux {\tt convert}
% program found in {\tt imagemagick}).

% When you include graphs you should make sure that the images you
% include are not raster images (gif, png etc) but a vector image that
% scales when you zoom-in. In Fig.\ref{fig:images} you see the same
% graph saved as a raster image (png) compared to a vector graphic
% image. You might not see the difference but if you zoom-in you will
% see that the vector image scales.

% \begin{figure}[h]
%   \centering
%   \begin{subfigure}{.5\textwidth}
%     \centering
%     \includegraphics[scale=0.45]{fib.png}
%     \caption{using raster graphics}
%   \end{subfigure}%
%   \begin{subfigure}{.5\textwidth}
%     \centering
%     \includegraphics[scale=0.45]{fib.pdf}
%     \caption{using vector graphics.}
%   \end{subfigure}
%   \caption{Difference in image formats.}
%   \label{fig:images}
% \end{figure}

% An alternative to including a graph produced by a separate program is
% to describe the graph in \LaTeX. This can be done using the TikZ
% library. This library is used to create all types of graphics and the
% learning curve is quite steep. The benefit is that the \LaTeX document
% becomes self contained and that you are in complete control over the result.

% The data can either be written in the latex source file but better read
% from a separate file. Reading from a separate file makes it easier to
% combine the output from a benchmark with the report. If you construct
% your benchmark to produce a file with the x and y values in columns
% you can plot them using a simple {\tt \textbackslash addplot}
% command. If you do changes to your program you simply run the
% benchmark again and re-compile the \LaTeX file.

% \begin{figure}
%   \centering
%   \begin{tikzpicture}
%     \begin{axis}[
%       xmin=12, xmax=28, ymin=0, ymax=3500,
%       xlabel=n, ylabel={time in $\mu s$},
%       width=8cm, height=6cm]
%       \addlegendentry{run time fib(n)};
%       \addplot[] table {fib.dat};
%     \end{axis}

%   \end{tikzpicture}
%   \caption{The same graph using TikZ}
%   \label{fig:tikz}
% \end{figure}

% The graph in Fig.\ref{fig:tikz} is generated using Tikz and as you can
% see, I know have the time in "$\mu s$" instead of in "us".

