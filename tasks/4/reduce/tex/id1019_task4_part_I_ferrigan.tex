\documentclass[a4paper,11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\usepackage{amsmath}

% Code highligting
% \usepackage{minted}
\usepackage[outputdir=output/tex]{minted} % iom min makefile

\newenvironment{longlisting}{\captionsetup{type=listing}}{}
% \renewcommand\listoflistingscaption{Källkod....}
\renewcommand\listoflistingscaption{List of source codes}
%\setmintedinline[sql]{breaklines=true,breakanywhere=true} % necessary for breakanywhere to work later on.

\usepackage{graphicx}
\usepackage{pgf}
\usepackage{wrapfig}
\usepackage[font=footnotesize,labelfont=bf,skip=1pt]{caption}
\usepackage{subcaption}

\usepackage{pgfplots}
\pgfplotsset{compat=1.18}

\usepackage{pgfplotstable}
\usepackage{booktabs}

% Spacing
\usepackage{titlesec}
%\titlespacing*{\section}{0pt}{2ex plus 1ex minus .2ex}{1ex plus .2ex}
%\titlespacing*{\subsection}{0pt}{1ex plus 1ex minus .2ex}{1ex plus .2ex}

\usepackage{hyperref}

\begin{document}

\title{
    Reduce and friends
    \\Part One
\\\small{Programmering II, ID1019, VT24 P1}
}
\author{Vincent Ferrigan \href{mailto:ferrigan@kth.se}{ferrigan@kth.se}}

% \date{\today}
\date{Spring Term 2023}

\maketitle

\section*{Introduction}
\label{sec:introduction}
The chief objective of this two-part assignment is to explore the significance and utility
of \emph{higher-order functions}.

Part one, covered in this report, consists of tackling list manipulations through
''traditional methods''.
The purpose of this is to discover underlying patterns.
Here, both regular and tail recursive solutions will be both
demonstrated and compared.
The second part re-implements these operations by using higher-order functions,
i.e.\ implementing generic solutions.
%Here, \emph{anonymous functions} are treated as \emph{first-class citizens}.
%This will help students understand and apply the three main patterns of
%higher-order functions: \emph{map}, \emph{reduce}, and \emph{filter}.
%
%The final task involves the use of the pipe operator
%\mintinline{elixir}{|>}
%to streamline
%function calls and improve code readability.
%The pipe operator is the main operator for function composition in Elixir.

This assignment is based on the instruction
\href{https://people.kth.se/~johanmon/courses/id1019/seminars/reduce/reduce.pdf}{'Reduce and friends'}
by course examiner Johan Montelius.
The Mix-project for this assignment, including all relative functions, Unit-test and benchmarks can be found on GitHub:
\href{https://github.com/VincentFerrigan/kth-id1019-programming-ii/tree/main/tasks/4/reduce}{Repo Programming II - Reduce}% TODO FUNKAR DEN? ÄNDRA NAMN
\section*{Methods}
\label{sec:methods}
\subsection*{Literature Study}
\label{subsec:literaturestudy}
The pre-recorded lectures on
\href{https://canvas.kth.se/courses/44911/assignments/syllabus}{''v6 Högre ordningens funktioner''},
given by the course examiner, were reviewed.
Elixir-syntax and similar topics were acquired
from both the
\href{https://elixir-lang.org/docs.html}{Elixir official documentation}
and the free Elixir Tutorial
\href{https://elixirschool.com/en}{Elixir School
website}.
The author also relied on textbooks found on
\href{https://learning.oreilly.com}{O'Reilly Media},
especially Brute Tate's
\href{https://learning.oreilly.com/library/view/programmer-passport-elixir/9781680509649/}{Programmer Passport: Elixir}.
\subsubsection*{Tools and packages}
\label{subsec:tools}
All code was written in \emph{IntelliJ IDEA}.
Quick-fixes and editing was, however, done in \emph{Vim}.
\emph{GIT} and \emph{GitHub} were used for version control.
Tests were performed with Elixir's built-in test framework \emph{ExUnit.}
The report was written in \LaTeX.
\subsubsection*{Test Driven Development}
\label{subsec:ttd}
The development was an iterative approach with ''trail and errors''.
The author practiced
\href{https://www.elixirwiki.com/wiki/Test-Driven_Development_in_Elixir}{Test Driven Development}
(TDD).
The basic steps follow the \emph{Red-Green-Refactor cycle};
writing failing tests (Red), make them pass (Green),
and finally refactor the code.
For example, before creating all functions that fall under the ''reduce-pattern'',
one can first write a couple of test cases, as illustrated in the test-examples below.
The product of an empty list should be one (the empty product), since one is the identity element for multiplication.
The sum of an empty list must also result in its identity element, which is zero.
\inputminted[
    label=REDUCE TESTS,
    firstline=19,
    lastline=39,
    xleftmargin=-3mm,  % Adjust this value as needed
    fontsize=\footnotesize,
]{elixir}{../test/reduce_test.exs}
\section*{Result}
\label{sec:result}
The ten list operations were divided into the following three underlying patterns:
\begin{description}
    \setlength{\itemsep}{-1mm} % Decreases the space between items
    \item[map:] inc, dec, mul, rem
    \item[reduce:] length, sum, prod
    \item[filter:] even, odd, div
\end{description}
Since all
\href{https://github.com/VincentFerrigan/kth-id1019-programming-ii/tree/main/tasks/4/reduce/lib/reduce.ex}{code (lib/reduce.ex)} and % TODO FUNKAR DEN? ÄNDRA NAMN
\href{https://github.com/VincentFerrigan/kth-id1019-programming-ii/tree/main/tasks/4/reduce/test/reduce_test.exs}{tests (test/reduce\_test.exs)}
could be found on GitHub, the author has chosen to only present a few of the functions.
\subsubsection*{Map}
Recursion typically involves two main components:
a base case and recursive cases.
The base case is the condition that ends the recursion
by not making a further recursive call.
The recursive cases are the conditions that continue the recursion by making
a further recursive call to the function.
In the code example below,
\mintinline{elixir}{def map_mul([], _n), do: []} is the base case while
\mintinline{elixir}{def map_mul([x|xs], n), do: [x*n|map_mul(xs, n)]} is the recursive call.
\inputminted[
label=map,
firstline=54,
lastline=56,
xleftmargin=-3mm,  % Adjust this value as needed
fontsize=\footnotesize,
]{elixir}{../lib/reduce.ex}
The function
\mintinline{elixir}{map:mul/2} multiplies each element in the list by
\mintinline{elixir}{n}.
\subsubsection*{Reduce}
Both function
\mintinline{elixir}{simple_reduce_prod/1} and
\mintinline{elixir}{acc_reduce_prod/1} calculate the product of all elements in the list
\inputminted[
    label=simple reduce,
    firstline=85,
    lastline=87,
    xleftmargin=-3mm,  % Adjust this value as needed
    fontsize=\footnotesize,
]{elixir}{../lib/reduce.ex}
\inputminted[
    label=acc reduce,
    firstline=111,
    lastline=117,
    xleftmargin=-3mm,  % Adjust this value as needed
    fontsize=\footnotesize,
]{elixir}{../lib/reduce.ex}
The difference is that the latter is tail-recursive,
with the subsequent helper function
\\\mintinline{elixir}{acc_reduce_prod/2}.
These functions are defined with
\mintinline{elixir}{defp}, making them private,
which is why they serve as helpers to the public-facing wrapper function
\\\mintinline{elixir}{acc_reduce:prod/1}.
The first

\mintinline{elixir}{acc_reduce_prod([], acc)},
defines the base case for the recursion.
When the list is empty, it returns the accumulated value,
effectively ending the recursion.
\mintinline{elixir}{acc_reduce_prod([x|xs], acc)},
handles the recursive case,
taking the head of the list
\mintinline{elixir}{x},
multiplying it with the accumulator
\mintinline{elixir}{acc},
and then recursively calling itself with the tail of the list
\mintinline{elixir}{xs} and the new accumulated value
\mintinline{elixir}{acc * x}.
\subsubsection*{Filter}
The wrapper function
\mintinline{elixir}{filter_odd/1}
with its helper function
\mintinline{elixir}{filter_odd/2}
uses
tail recursion to filter odd numbers from a list.
% TODO HÄR ÄR DU
\inputminted[
    label=filter,
    firstline=137,
    lastline=145,
    xleftmargin=-3mm,  % Adjust this value as needed
    fontsize=\footnotesize,
]{elixir}{../lib/reduce.ex}
The helper function uses an accumulator (acc) to collect the results.
Since elements are prepended to the accumulator,
the resulting list would be in reverse order compared to the original list.
To preserve the original element order,
\mintinline{elixir}{Enum.reverse(acc)} is called before returning the final
result.
\section*{Discussion}
\label{sec:discussion}
The recursive calls in the helper functions above are structured in such a way
(tail calls) that Elixir (or the Erlang VM, BEAM, it runs on)
can optimize them.
Regular recursion, exemplified above in
\mintinline{elixir}{simple_reduce_prod/1}),
involves functions that make their recursive call but still
have some computation to do after the call returns
(\mintinline{elixir}{x * simple_reduce_prod(xs)}), potentially leading to
larger memory usage due to the call stack.

Tail recursion, on the other hand, as exemplified above in both
\\\mintinline{elixir}{acc_reduce_prod/1} and
\mintinline{elixir}{filter_odd/1},
is a specific form of recursion where the recursive call is the last operation
in the function.
This allows for optimizations such as tail call optimization
(TCO), where the compiler can reuse the current function's stack frame for the
recursive call, significantly reducing memory usage and preventing stack
overflow errors.
Tail recursion is therefore considered more efficient and
performant for certain algorithms, especially in languages and environments
that support TCO.
\end{document}

% regular recursion involves functions that make their recursive call but still
% have some computation to do after the call returns, potentially leading to
% larger memory usage due to the call stack. Tail recursion, on the other hand,
% is a specific form of recursion where the recursive call is the last operation
% in the function. This allows for optimizations such as tail call optimization
% (TCO), where the compiler can reuse the current function's stack frame for the
% recursive call, significantly reducing memory usage and preventing stack
% overflow errors. Tail recursion is therefore considered more efficient and
% performant for certain algorithms, especially in languages and environments
% that support TCO.

%The head function
%\mintinline{elixir}{}
%......
%\begin{minted}[fontsize=\footnotesize]{elixir}
%iex>
%iex>
%
%
%:ok
%\end{minted}
%This function .....

