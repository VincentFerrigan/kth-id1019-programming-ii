\documentclass[a4paper,11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\usepackage{amsmath}

% Code highligting
% \usepackage{minted}
\usepackage[outputdir=output/tex]{minted} % iom min makefile

\newenvironment{longlisting}{\captionsetup{type=listing}}{}
% \renewcommand\listoflistingscaption{Källkod....}
\renewcommand\listoflistingscaption{List of source codes}
%\setmintedinline[sql]{breaklines=true,breakanywhere=true} % necessary for breakanywhere to work later on.

\usepackage{graphicx}
\usepackage{pgf}
\usepackage{wrapfig}
\usepackage[font=footnotesize,labelfont=bf,skip=1pt]{caption}
\usepackage{subcaption}

\usepackage{pgfplots}
\pgfplotsset{compat=1.18}

\usepackage{pgfplotstable}
\usepackage{booktabs}

% Spacing
\usepackage{titlesec}
%\titlespacing*{\section}{0pt}{2ex plus 1ex minus .2ex}{1ex plus .2ex}
%\titlespacing*{\subsection}{0pt}{1ex plus 1ex minus .2ex}{1ex plus .2ex}

\usepackage{hyperref}

\begin{document}

\title{
    Reduce and friends
    \\Part Two
\\\small{Programmering II, ID1019, VT24 P1}
}
\author{Vincent Ferrigan \href{mailto:ferrigan@kth.se}{ferrigan@kth.se}}

% \date{\today}
\date{Spring Term 2023}

\maketitle

\section*{Introduction}
\label{sec:introduction}
The chief objective of this two-part assignment is to explore the significance and utility
of \emph{higher-order functions}.

The first part consisted of tackling list manipulations through
''traditional methods''.
The purpose was to discover underlying patterns.
Here, both regular and tail recursive solutions were both
demonstrated and compared.

This second part, covered by this report, re-implements these operations by using
higher-order functions, i.e.\ implementing generic solutions.
Here, \emph{anonymous functions} are treated as \emph{first-class citizens}.
This will help students understand and apply the three main patterns of
higher-order functions: \emph{map}, \emph{reduce}, and \emph{filter}.

The final task involves the use of the pipe operator
\mintinline{elixir}{|>}
to streamline
function calls and improve code readability.
The pipe operator is the main operator for function composition in Elixir.

This assignment is based on the instruction
\href{https://people.kth.se/~johanmon/courses/id1019/seminars/reduce/reduce.pdf}{'Reduce and friends'}
by course examiner Johan Montelius.
The Mix-project for this assignment, including all relative functions, Unit-test and benchmarks can be found on GitHub:
\href{https://github.com/VincentFerrigan/kth-id1019-programming-ii/tree/main/tasks/4/reduce}{Repo Programming II - Reduce}% TODO FUNKAR DEN? ÄNDRA NAMN

\section*{Methods}
\label{sec:methods}
\subsection*{Literature Study}
\label{subsec:literaturestudy}
The pre-recorded lectures on
\href{https://canvas.kth.se/courses/44911/assignments/syllabus}{''v6 Högre ordningens funktioner''},
given by the course examiner, were reviewed.
Elixir-syntax and similar topics were acquired
from both the
\href{https://elixir-lang.org/docs.html}{Elixir official documentation}
and the free Elixir Tutorial
\href{https://elixirschool.com/en}{Elixir School
website}.
The author also relied on textbooks found on
\href{https://learning.oreilly.com}{O'Reilly Media},
especially Brute Tate's
\href{https://learning.oreilly.com/library/view/programmer-passport-elixir/9781680509649/}{Programmer Passport: Elixir}.

\subsubsection*{Tools and packages}
\label{subsec:tools}
All code was written in \emph{IntelliJ IDEA}.
Quick-fixes and editing was, however, done in \emph{Vim}.
\emph{GIT} and \emph{GitHub} were used for version control.
Tests were performed with Elixir's built-in test framework \emph{ExUnit.}
The report was written in \LaTeX.

\subsubsection*{Test Driven Development}
\label{subsec:ttd}
The development was an iterative approach with ''trail and errors''.
The author practiced
\href{https://www.elixirwiki.com/wiki/Test-Driven_Development_in_Elixir}{Test Driven Development}
(TDD).
The basic steps follow the \emph{Red-Green-Refactor cycle};
writing failing tests (Red), make them pass (Green),
and finally refactor the code.
For example, before creating the three higher-order functions,
one can first write a couple of test cases, as illustrated in the test-examples below.
The product of an empty list should be one (the empty product),
since one is the identity element for multiplication.
The sum of an empty list must also result in its identity element, which is zero.
\inputminted[
    label=REDUCE TESTS,
    firstline=52,
    lastline=76,
    xleftmargin=-3mm,  % Adjust this value as needed
    fontsize=\footnotesize,
]{elixir}{../test/reduce_test.exs}
As illustrated in the test cases above,
when applicable, the
\emph{anonymous functions} that are passed as second arguments, are written in
compact form, i.e. using the
\mintinline{elixir}{&} shorthand syntax in Elixir.
Here, one can replace the parameters with their positional equivalents
(\mintinline{elixir}{&1},
\mintinline{elixir}{&2}, etc.).
An even more concise way is to reference existing named functions
named functions directly using the
\mintinline{elixir}{&} operator followed by the function name and its arity (number of arguments).
As in the test case ''Return even numbers'' where
\mintinline{elixir}{&rem(&1, 2)} captures the named-function
\mintinline{elixir}{rem/2}, and the ability to write
\mintinline{elixir}{&Kernel.<*>/2} instead of
\mintinline{elixir}{&(&1 <*> &2)} as in all the
\mintinline{elixir}{reduce/3} test-cases above.
\section*{Result}
\label{sec:result}
All
\href{https://github.com/VincentFerrigan/kth-id1019-programming-ii/tree/main/tasks/4/reduce/lib/reduce.ex}{code (lib/reduce.ex)} and % TODO FUNKAR DEN? ÄNDRA NAMN
\href{https://github.com/VincentFerrigan/kth-id1019-programming-ii/tree/main/tasks/4/reduce/test/reduce_test.exs}{tests (test/reduce\_test.exs)}
can be found on GitHub.
\subsection*{The three higher order functions}
The first higher-order function is
\mintinline{elixir}{map/2}, which applies a given function
\mintinline{elixir}{(A -> B)} to each element of a list.
\inputminted[
label=map,
firstline=174,
lastline=176,
xleftmargin=-3mm,  % Adjust this value as needed
fontsize=\footnotesize,
]{elixir}{../lib/reduce.ex}
\inputminted[
    label=map,
    firstline=170,
    lastline=172,
    xleftmargin=-3mm,  % Adjust this value as needed
    fontsize=\footnotesize,
]{elixir}{../lib/reduce.ex}
This implementation of map is a classic example of recursion,
where the function calls itself with a smaller portion of the problem
(the tail of the list) until it reaches a base case (an empty list),
at which point it begins to construct and return the new list by combining
the results of the function application to each element.

The higher-order function
\mintinline{elixir}{reduce/3}
reduces a list to a single value by applying a function to each element
and an accumulator.
\inputminted[
    label=map,
    firstline=198,
    lastline=200,
    xleftmargin=-3mm,  % Adjust this value as needed
    fontsize=\footnotesize,
]{elixir}{../lib/reduce.ex}
\inputminted[
    label=map,
    firstline=170,
    lastline=172,
    xleftmargin=-3mm,  % Adjust this value as needed
    fontsize=\footnotesize,
]{elixir}{../lib/reduce.ex}
The function
\mintinline{elixir}{`func`} is called with two arguments;
the current accumulator
and each element of the list.
The result of
\mintinline{elixir}{`func`}
becomes the new accumulator value.
The process repeats
for each element in the list, starting with the initial value of `acc`.

\subsubsection*{Filter -- version 1}
The higher-order function
\mintinline{elixir}{filter1/2}
''filters'' a list by applying a predicate function to each element,
returning those for which the function returns `true`.
\inputminted[
    label=map,
    firstline=213,
    lastline=218,
    xleftmargin=-3mm,  % Adjust this value as needed
    fontsize=\footnotesize,
]{elixir}{../lib/reduce.ex}
\inputminted[
    label=map,
    firstline=209,
    lastline=211,
    xleftmargin=-3mm,  % Adjust this value as needed
    fontsize=\footnotesize,
]{elixir}{../lib/reduce.ex}

\subsubsection*{Filter -- version 2}
The wrapper function
\mintinline{elixir}{filter/2}
with its helper function
\mintinline{elixir}{filter_acc/3}
uses
tail recursion to filter odd numbers from a list.
\inputminted[
    label=map,
    firstline=236,
    lastline=244,
    xleftmargin=-3mm,  % Adjust this value as needed
    fontsize=\footnotesize,
]{elixir}{../lib/reduce.ex}
The helper function uses an accumulator (acc) to collect the results.
Since elements are prepended to the accumulator,
the resulting list would be in reverse order compared to the original list.
To preserve the original element order,
\mintinline{elixir}{Enum.reverse(acc)} is called before returning the final
result.

\subsubsection*{Composite functions}
The following function
\mintinline{elixir}{sum_of_squares_below/2},
calculates the sum of the squares of all elements in the list
that are less than
\mintinline{elixir}{`n`}
i.e. the threshold value.
Only elements less than
\mintinline{elixir}{`n`} are considered.
\inputminted[
    label=map,
    firstline=263,
    lastline=269,
    xleftmargin=-3mm,  % Adjust this value as needed
    fontsize=\footnotesize,
]{elixir}{../lib/reduce.ex}
\inputminted[
    label=map,
    firstline=258,
    lastline=260,
    xleftmargin=-3mm,  % Adjust this value as needed
    fontsize=\footnotesize,
]{elixir}{../lib/reduce.ex}
This function demonstrates function composition with piping
in Elixir.
\section*{Discussion}
\label{sec:discussion}
\subsubsection*{Tail recursion}
The recursive calls in the helper functions above are structured in such a way
(tail calls) that Elixir (or the Erlang VM, BEAM, it runs on)
can optimize them.

Tail recursion, as exemplified above in both
\mintinline{elixir}{reduce/2})
is a specific form of recursion where the recursive call is the last operation
in the function.
This allows for optimizations such as tail call optimization
(TCO), where the compiler can reuse the current function's stack frame for the
recursive call, significantly reducing memory usage and preventing stack
overflow errors.
Tail recursion is therefore considered more efficient and
performant for certain algorithms, especially in languages and environments
that support TCO.
\subsubsection*{Why Use a Wrapper Function and Helper Functions?}
Both function
\mintinline{elixir}{filter1/2} and
\mintinline{elixir}{filter/2} aim to filter a list based on a predicate function (func)
that returns a boolean value.
However, only one of them are tail recursive.
The former is not since the recursive call is not the last action it takes.
After the recursive call, it might either prepend the current element to the
result of the recursive call or just return the result of the recursive call.
This ''prepending'' action after the recursive call prevents it from being tail-recursive.

The latter filter function on the other,
through its helper
\mintinline{elixir}{filter_acc/3}, is tail-recursive.
The recursive call to
\mintinline{elixir}{filter_acc/3} is the last operation performed
in each branch of the if statement.
One can of course discuss if this implementation is strictly tail-recursive due to the Enum.reverse call at the end.
However, the recursive calls themselves are structured to benefit from the tail call optimization as much as possible.

The overall time complexity of the
filter function with an accumulator and final list reversal is $O(n)$.
Even though there are two distinct linear operations (traversing and reversing),
when discussing Big O notation,
constant factors (like the ''$2$'' in $O(2n)$) are ignored because the focus is
on how the execution time grows with the size of the input.
Thus, the overall complexity is simplified to $O(n)$.

The primary reason to choose one implementation over another,
when both share the same time complexity,
is their space complexity.
The choice to use the accumulator-based,
tail-recursive filter over
\mintinline{elixir}{filter1} is motivated by considerations of stack usage
and as a consequnce its ability to handle large list -- thanks to the advantages of tail call optimization.
\end{document}

%%This step is necessary because prepending to a list is more efficient than appending, which would otherwise require traversing the entire list for each addition.
%By passing the accumulator along with each recursive call and prepending the
%current element when it satisfies the condition (being odd in this scenario),
%this approach avoids the performance penalty associated with list concatenation or repeated list construction.

% regular recursion involves functions that make their recursive call but still
% have some computation to do after the call returns, potentially leading to
% larger memory usage due to the call stack. Tail recursion, on the other hand,
% is a specific form of recursion where the recursive call is the last operation
% in the function. This allows for optimizations such as tail call optimization
% (TCO), where the compiler can reuse the current function's stack frame for the
% recursive call, significantly reducing memory usage and preventing stack
% overflow errors. Tail recursion is therefore considered more efficient and
% performant for certain algorithms, especially in languages and environments
% that support TCO.
