\documentclass[a4paper,11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\usepackage{amsmath}

% Code highligting
% \usepackage{minted}
\usepackage[outputdir=output/tex]{minted} % iom min makefile

\newenvironment{longlisting}{\captionsetup{type=listing}}{}
% \renewcommand\listoflistingscaption{Källkod....}
\renewcommand\listoflistingscaption{List of source codes}
%\setmintedinline[sql]{breaklines=true,breakanywhere=true} % necessary for breakanywhere to work later on.

\usepackage{graphicx}
\usepackage{pgf}
\usepackage{wrapfig}
\usepackage[font=footnotesize,labelfont=bf,skip=1pt]{caption}
\usepackage{subcaption}

\usepackage{pgfplots}
\pgfplotsset{compat=1.18}

\usepackage{pgfplotstable}
\usepackage{booktabs}

% Spacing
\usepackage{titlesec}
%\titlespacing*{\section}{0pt}{2ex plus 1ex minus .2ex}{1ex plus .2ex}
%\titlespacing*{\subsection}{0pt}{1ex plus 1ex minus .2ex}{1ex plus .2ex}

\usepackage{hyperref}

\begin{document}

\title{
    Evaluating an expression
\\\small{Programmering II, ID1019, VT24 P1}
}
\author{Vincent Ferrigan \href{mailto:ferrigan@kth.se}{ferrigan@kth.se}}

% \date{\today}
\date{Spring Term 2023}

\maketitle

\section*{Introduction}
\label{sec:introduction}
The chief objective of this assignment is to evaluate mathematical expression containing variables.
The task involves implementing a function
\mintinline{elixir}{eval/2} that takes an \emph{expression} and an \emph{environment} to evaluate the expression to a
literal.
The expressions are represented as tuples with operators like
\mintinline{elixir}{:add} for addition,
\mintinline{elixir}{:sub} for subtraction,
\mintinline{elixir}{:mul} for multiplication, and
\mintinline{elixir}{:div} for division,
and literals including integers as
\mintinline{elixir}{:num}, variables as
\mintinline{elixir}{:var}, and numbers as
\mintinline{elixir}{:q}.

This assignment is based on the instruction
\href{https://people.kth.se/~johanmon/courses/id1019/seminars/expression/expression.pdf}{'Evaluating an expression'}
by course examiner Johan Montelius.
The Mix-project for this assignment, including all relative functions, Unit-test and benchmarks can be found on GitHub:
\href{https://github.com/VincentFerrigan/kth-id1019-programming-ii/tree/main/tasks/3/expression}{Repo Programming II - Expression}% TODO FUNKAR DEN? ÄNDRA NAMN
\section*{Methods}
\label{sec:methods}
\subsection*{Literature Study}
\label{subsec:literaturestudy}
The pre-recorded lectures on
\href{https://canvas.kth.se/courses/44911/assignments/syllabus}{''Lambdakalkyl''},
given by the course examiner, were reviewed.
Elixir-syntax and similar topics were acquired
from both the
\href{https://elixir-lang.org/docs.html}{Elixir official documentation}
and the free Elixir Tutorial
\href{https://elixirschool.com/en}{Elixir School
website}.
The author also relied on textbooks found on
\href{https://learning.oreilly.com}{O'Reilly Media},
especially Brute Tate's
\href{https://learning.oreilly.com/library/view/programmer-passport-elixir/9781680509649/}{Programmer Passport: Elixir}.
\subsubsection*{Tools and packages}
\label{subsec:tools}
All code was written in \emph{IntelliJ IDEA}.
Quick-fixes and editing was, however, done in \emph{Vim}.
\emph{GIT} and \emph{GitHub} were used for version control.
Tests were performed with Elixir's built-in test framework \emph{ExUnit.}
The report was written in \LaTeX.
\subsubsection*{The overall Work-flow}
\label{subsec:workflow}
The development was an iterative approach with ''trail and errors''.
The author practiced
\href{https://www.elixirwiki.com/wiki/Test-Driven_Development_in_Elixir}{Test Driven Development}
(TDD).
The basic steps follow the \emph{Red-Green-Refactor cycle};
writing failing tests (Red), make them pass (Green),
and finally refactor the code.
For example, before creating a helper-function that reduces rational numbers,
one can first write a test-case.
As illustrated in the test-example below, the result is expected to be
$\frac{3}{2}$ rather than $\frac{6}{4}$.
\begin{minted}[fontsize=\footnotesize]{elixir}
test "Evaluate 3x/4, where x = 2" do
  e = {:div, {:mul, {:num, 3}, {:var, :x}}, {:num, 4}}
  env = %{x: 2}
  assert Expression.eval(e, env) == {:q, 3, 2}
end
\end{minted}
\section*{Result}
\label{sec:result}
Since all
\href{https://github.com/VincentFerrigan/kth-id1019-programming-ii/tree/main/tasks/3/expression/lib/expression.ex}{code (lib/expression.ex)} and % TODO FUNKAR DEN? ÄNDRA NAMN
\href{https://github.com/VincentFerrigan/kth-id1019-programming-ii/tree/main/tasks/3/expression/test/expression_test.exs}{tests (test/expression\_test.exs)}
could be found on GitHub, the author has chosen only to present multiplication and division
of both integers and rational numbers.

The head function
\mintinline{elixir}{Expression.run/2}
evaluates and prints the given mathematical expression based on the provided environment.
\begin{minted}[fontsize=\footnotesize]{elixir}
iex> e = {:div, {:mul, {:num, 3}, {:var, :x}}, {:mul, {:num, 2}, {:var, :y}}}
iex> Expression.run(e, %{x: 2, y: 4})
Evaluating 3x/2y, where %{x: 2, y: 4}.
Result: 3/4
:ok
\end{minted}
This function takes a mathematical expression represented in a structured format
(as defined by the
\mintinline{elixir}{expr()} type),
and an environment,
\mintinline{elixir}{env} as a mapping of variables to their values.
The given expression and the final simplified evaluation are pretty printed on the console.
On successful execution, the function returns an
\mintinline{elixir}{:ok}.
\begin{minted}[fontsize=\footnotesize]{elixir}
@spec run(expr(), map()) :: :ok
def run(ast, env) do
  IO.write("Evaluating #{pretty_print(ast)}, where #{inspect(env)}.\n")
  IO.write("Result: #{pretty_print(eval(ast, env))}\n")
  :ok
end
\end{minted}
As previously mentioned, only a couple of auxiliary functions will be briefly explained.
\subsubsection*{DSL}
As in the first assigment, \emph{Taking the Derivative}, the assignment also includes a form of metaprogramming
i.e. \mintinline{elixir}{@type} definitions creating a small \emph{Domain Specific Language} DSL.
A DSL is a specialized mini-language created to express ideas, configurations, or instructions in a specific domain
more efficiently and clearly.
In this case, the domain is mathematical expressions,
and our Abstract Syntax Tree (AST) structure is tailored to express these expressions in a specific, structured way.
\begin{minted}[fontsize=\footnotesize]{elixir}
@type literal() :: {:num, number()} | {:var, atom() | {:q, number(), number()}}

@type expr() ::   {:add, expr(), expr()} | {:sub, expr(), expr()}
                | {:mul, expr(), expr()} | {:div, expr(), expr()}
                | literal()
\end{minted}
\subsubsection*{Evaluation}
In Elixir it is possible to have several definitions of the same function and arity.
This technique is called function-overloading where and in this case.
To choose which function to call,
Elixir pattern matches the parameters.
(The order of matching is top-down as in regular pattern matching.)
Both
\mintinline{elixir}{eval/2} and its helper-functions
are overloaded.
\begin{minted}[fontsize=\footnotesize]{elixir}
@spec eval(expr(), map()):: literal()
def eval({:num, n}, _), do: {:num, n}
def eval({:var, v}, env), do: {:num, Map.get(env, v)}
...etc
def eval({:mul, e1, e2}, env), do: multiplication(eval(e1, env), eval(e2, env))
def eval({:div, e1, e2}, env), do: division(eval(e1, env), eval(e2, env))
def eval({:q, a, a}, env), do: eval({:num, 1}, env)
def eval({:q, a, 1}, env), do: eval({:num, a}, env)
def eval({:q, a, a}, env), do: eval({:num, 1}, env)
def eval({:q, a, b}, env), do: division(eval({:num, a}, env), eval({:num, b}, env))
\end{minted}
This is a handy way to parse the given AST.
So how does one specifically deal with rational numbers?
For example, multiply two fractions with different denominators
The program must multiply the numerators and denominators separately:
$\frac{a}{b} \cdot \frac{c}{d} = \frac{ac}{bd}$
and then reduce the resulting rational number.
Here, the program must calculate the greatest common divisor (GCD)
of the numerator and denominator, and divide both by the GCD.
\begin{minted}[fontsize=\footnotesize]{elixir}
# Evaluate given multiplication of two expressions based on provided environment `env`.
def eval({:mul, e1, e2}, env), do: multiplication(eval(e1, env), eval(e2, env))

# Perform multiplication between two expressions, handling both integers and rational numbers.
defp multiplication({:q, a, b}, {:q, c, d}), do: division({:num, a * c}, {:num, b * d})
...etc

# Simplify rational numbers into integers when applicable.
defp division({:num, n}, {:num, n}), do: {:num, 1}
defp division({:num, n}, {:num, 1}), do: {:num, n}

# Simplify the result by dividing both numerator and denominator by their GCD.
defp division({:num, n1}, {:num, n2}) do
  gcd = Integer.gcd(convert_float_to_int_if_whole(n1), convert_float_to_int_if_whole(n2))
  {:q, convert_float_to_int_if_whole(n1/gcd), convert_float_to_int_if_whole(n2/gcd)}
end

# Convert a float to an integer if it's a whole number, otherwise raise an ArgumentError.
defp convert_float_to_int_if_whole(float) do
  truncated = trunc(float)
  if truncated == float do truncated
  else raise ArgumentError,
      message: "Input #{float} is not a whole number and cannot be converted to an integer."
  end
end
\end{minted}

\section*{Discussion}
\label{sec:discussion}
As mentioned in the author's first report,
developing the simplification process was then quite tricky.
The module \mintinline{elixir}{derivative} did not simplify
all algebraic expressions all the way.
One issue was applying the quotient rule for exponents.
\begin{minted}[fontsize=\small]{elixir}
iex(1)> f = {:div, {:num, 1}, {:mul, {:num, 2}, {:var, :x}}}
{:div, {:num, 1}, {:mul, {:num, 2}, {:var, :x}}}
iex(2)> Derivative.run(f, :x, 3)
The steps taken to find the derivative of function (1/2x),
at given value of x = 3.
Derivative: ((0 * 2x) + -((1 * (2 * 1) + 0x))/(2x)^2)
Simplified: (-2/(2x)^2)
Calculated: (-2/36.0)
:ok
\end{minted}
With this module, the result $\frac{-2}{36}$ would have been reduced to $\frac{-1}{18}$.
\begin{minted}[fontsize=\small]{elixir}
iex(1)> env = %{x: 3}
iex(2)> e = {:div, {:num, -2}, {:num, 36}}
{:div, {:num, -2}, {:num, 36}}
iex(3)> Expression.run(e, env)
Evaluating -2/36, where %{x: 3}.
Result: -1/18
:ok
\end{minted}
\subsubsection*{Error handling}
How should one handle division by zero appropriately?
When trying to divide by zero, the author chose to use Elixir's build function
to raise an error.
\begin{minted}[fontsize=\small]{elixir}
defp division(_, {:num, 0}) do
  raise ArgumentError, message: "Attempted to divide by zero."
end
\end{minted}
Was this an okay approach, or should the solution have been indicating an ''error''
with an atom followed by \verb|stderr|/\verb|stdout| with the help of \verb|IO|?
\end{document}